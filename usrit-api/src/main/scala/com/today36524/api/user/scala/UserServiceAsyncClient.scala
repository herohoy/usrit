package com.today36524.api.user.scala

        import com.github.dapeng.core._;
        import com.github.dapeng.org.apache.thrift._;
        import java.util.ServiceLoader;
        import java.util.concurrent.CompletableFuture;
        import com.today36524.api.user.scala.UserServiceAsyncCodec._;
        import com.today36524.api.user.scala.service.UserServiceAsync;
        import scala.concurrent.duration._
        import scala.concurrent.{Future, Promise}
        import scala.concurrent.ExecutionContext.Implicits.global

        /**
         * Autogenerated by Dapeng-Code-Generator (1.2.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated

        **/
        class UserServiceAsyncClient extends UserServiceAsync {

        val serviceName = "com.today36524.api.user.service.UserService"
        val version = "1.0.0"
        val pool = {
          val serviceLoader = ServiceLoader.load(classOf[SoaConnectionPoolFactory])
          if (serviceLoader.iterator().hasNext) {
            val poolImpl = serviceLoader.iterator().next().getPool
            poolImpl.registerClientInfo(serviceName,version)
            poolImpl
          } else null
        }

        def getServiceMetadata: String = {
          pool.send(
          serviceName,
          version,
          "getServiceMetadata",
          new getServiceMetadata_args,
          new GetServiceMetadata_argsSerializer,
          new GetServiceMetadata_resultSerializer
          ).success
        }

        /**
        *  java CompletableFuture => scala Future common function
        */
        def toScala[T,R](response: CompletableFuture[T])(extractor: T => R): Future[R] = {

          val promise = Promise[R]()
          response.whenComplete((res: T, ex) => {
            if (ex != null) promise.failure(ex)
            else promise.success(extractor(res))
          })
          promise.future
        }


        

            /**
            * 

    ### 用户注册

    #### 业务描述
        用户注册账户，用户密码需要加盐之后存储(加盐方案还么确定,小伙伴可以自己随意设计个简单的加解密方案)

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.RegisterUserRequest

    #### 前置检查
        1. 手机号码规则验证
        2. 手机号未被使用验证
        3. 密码规则,字母数字八位混合

    ####  逻辑处理
        1.密码加盐处理
        2.新增一条user记录
        3.返回结果 user_response.RegisterUserResponse

    #### 数据库变更
        1. insert into user() values()

    ####  事务处理
        无

    ####  输出
        1.user_response.RegisterUserResponse

            **/
            def registerUser(request:com.today36524.api.user.scala.request.RegisterUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.RegisterUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "registerUser",
            registerUser_args(request),
            new RegisterUser_argsSerializer(),
            new RegisterUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[registerUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 用户登录

    #### 业务描述
       用户登录

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.LoginUserRequest

    #### 前置检查
        1.手机号码规则验证
        2.密码规则,字母数字八位混合

    ####  逻辑处理
        1. 根据手机号码和密码查询用户记录
        2. 异常用户状态的用户登录返回 Exception

    #### 数据库变更
        1. select *  from user where telphone = ? and password = ?

    ####  事务处理
        无

    ####  输出
        1.user_response.LoginUserResponse

            **/
            def login(request:com.today36524.api.user.scala.request.LoginUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.LoginUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "login",
            login_args(request),
            new Login_argsSerializer(),
            new Login_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[login_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 用户修改个人资料

    #### 业务描述
       用户再注册之后完善个人资料,完善资料增加积分5

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.ModifyUserRequest

    #### 前置检查
        1. 邮箱规则验证
        2. qq 规则验证
        3. 用户状态判断只有用户状态为

    ####  逻辑处理
        1. 根据输入的参数计算用户积分
        2. 修改用户 email qq
        2. 修改完成之后调用积分action增加用户积分(完善资料增加积分5) ChangeUserIntegralAction

    #### 数据库变更
        1. update user set email = ? , qq = ? where id = ${userId}

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.ModifyUserAction

            **/
            def modifyUser(request:com.today36524.api.user.scala.request.ModifyUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.ModifyUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "modifyUser",
            modifyUser_args(request),
            new ModifyUser_argsSerializer(),
            new ModifyUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[modifyUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 冻结用户接口

    #### 业务描述
       用户因为触犯一些游戏规则,后台自检程序或者管理员会冻结该用户

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.FreezeUserRequest

    #### 前置检查
        1.用户状态检查(已冻结,已拉黑,已逻辑删除的用户不能冻结)

    ####  逻辑处理
        1. 设置用户状态为 FREEZE

    #### 数据库变更
        1. update user set status = ? , remark = ? where id = ${userId}

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.FreezeUserResponse

            **/
            def freezeUser(request:com.today36524.api.user.scala.request.FreezeUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.FreezeUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "freezeUser",
            freezeUser_args(request),
            new FreezeUser_argsSerializer(),
            new FreezeUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[freezeUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 拉黑用户接口

    #### 业务描述
       用户因为触犯一些游戏规则,后台自检程序或者管理员会拉黑该用户,拉黑用户把用户的积分置为0

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.BlackUserRequest

    #### 前置检查
        1.用户状态检查(已冻结,已拉黑,已逻辑删除的用户不能拉黑)

    ####  逻辑处理
        1. 设置用户状态为  BLACK
        2. 调用积分修改接口 ChangeUserIntegralAction

    #### 数据库变更
        1. update user set status = ? , remark = ? where id = ${userId}

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.BlackUserResponse

            **/
            def blackUser(request:com.today36524.api.user.scala.request.BlackUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.BlackUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "blackUser",
            blackUser_args(request),
            new BlackUser_argsSerializer(),
            new BlackUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[blackUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 记录积分改变流水

    #### 业务描述
       用户因为完成一些游戏规则或者触犯游戏规则导致积分减少或者增加,调用该接口修改用户积分

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.ChangeIntegralRequest

    #### 前置检查
        1.用户状态检查(已冻结,已拉黑,已逻辑删除的用户不能冻结)

    ####  逻辑处理
        1. 设置用户状态为 FREEZE

    #### 数据库变更
        1. update user set integral = ?  where id = ${userId}
        2. insert into integral_journal() values()

    ####  事务处理
        1. 无

    ####  输出
        1. i32 流水 Id

            **/
            def changeUserIntegral(request:com.today36524.api.user.scala.request.ChangeIntegralRequest 
            , timeout: Long = 5000) : Future[Int] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "changeUserIntegral",
            changeUserIntegral_args(request),
            new ChangeUserIntegral_argsSerializer(),
            new ChangeUserIntegral_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[changeUserIntegral_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 解冻用户接口

    #### 业务描述
       用户被冻结后，由于申请恢复或申诉错误操作并得到认可，对该用户进行解冻操作

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.UnreezeUserRequest

    #### 前置检查
        1.用户状态检查(未冻结,已拉黑,已逻辑删除的用户不能解冻)

    ####  逻辑处理
        1. 设置用户状态为 ACTIVATED

    #### 数据库变更
        1. update user set status = ? , remark = ? where id = ${userId}

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.UnfreezeUserResponse

            **/
            def unfreezeUser(request:com.today36524.api.user.scala.request.UnfreezeUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.UnfreezeUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "unfreezeUser",
            unfreezeUser_args(request),
            new UnfreezeUser_argsSerializer(),
            new UnfreezeUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[unfreezeUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 查询单个用户接口

    #### 业务描述
       通过用户id查询单个用户

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.GetUserRequest

    #### 前置检查
        1.用户id格式检查（非法id不能通过检查）

    ####  逻辑处理
        1. 查询单个用户并返回

    #### 数据库变更
        1. 无

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.GetUserResponse

            **/
            def getUser(request:com.today36524.api.user.scala.request.GetUserRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.GetUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "getUser",
            getUser_args(request),
            new GetUser_argsSerializer(),
            new GetUser_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[getUser_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 手机号查询单个用户接口

    #### 业务描述
       通过用户手机号查询单个用户

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.GetUserByTelephoneRequest

    #### 前置检查
        1.用户手机号格式检查（非法手机号不能通过检查）

    ####  逻辑处理
        1. 查询单个用户并返回，未查询到或查询到多个将报错

    #### 数据库变更
        1. 无

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.GetUserResponse

            **/
            def getUserByTelephone(request:com.today36524.api.user.scala.request.GetUserByTelephoneRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.GetUserResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "getUserByTelephone",
            getUserByTelephone_args(request),
            new GetUserByTelephone_argsSerializer(),
            new GetUserByTelephone_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[getUserByTelephone_result]]

            toScala(response)(_.success)

          }

          

            /**
            * 

    ### 分页查询用户接口

    #### 业务描述
       通过组合参数对用户数据进行分页查询

    #### 接口依赖
        无
    #### 边界异常说明
        无

    #### 输入
        1.user_request.FindUsersByPageRequest

    #### 前置检查
        1.相关参数格式检查（非法参数不能通过检查）

    ####  逻辑处理
        1. 分页查询用户数据，返回分页相关信息和用户列表，未查询到返回空列表

    #### 数据库变更
        1. 无

    ####  事务处理
        1. 无

    ####  输出
        1.user_response.FindUsersByPageResponse

            **/
            def findUsersByPage(request:com.today36524.api.user.scala.request.FindUsersByPageRequest 
            , timeout: Long = 5000) : Future[com.today36524.api.user.scala.response.FindUsersByPageResponse] = {

            val response = pool.sendAsync(
            serviceName,
            version,
            "findUsersByPage",
            findUsersByPage_args(request),
            new FindUsersByPage_argsSerializer(),
            new FindUsersByPage_resultSerializer()
            ,timeout).asInstanceOf[CompletableFuture[findUsersByPage_result]]

            toScala(response)(_.success)

          }

          
      }
      